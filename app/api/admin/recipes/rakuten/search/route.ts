import { NextRequest, NextResponse } from 'next/server'
import { isAdmin } from '@/lib/auth'

export async function GET(request: NextRequest) {
  try {
    // ÁÆ°ÁêÜËÄÖÊ®©Èôê„ÉÅ„Çß„ÉÉ„ÇØ
    const isAdminResult = await isAdmin(request)
    if (!isAdminResult) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { searchParams: urlParams } = new URL(request.url)
    const keyword = urlParams.get('keyword')
    const testMode = urlParams.get('test') === 'true' // „ÉÜ„Çπ„Éà„É¢„Éº„Éâ„Éë„É©„É°„Éº„Çø

    if (!keyword) {
      return NextResponse.json({ error: 'Keyword is required' }, { status: 400 })
    }

    // Ê•ΩÂ§©„É¨„Ç∑„ÉîAPI„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥IDÔºàÁí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÂèñÂæóÔºâ
    const applicationId = process.env.RAKUTEN_APPLICATION_ID

    // APIÊé•Á∂ö„ÉÜ„Çπ„ÉàÊÉÖÂ†±
    const apiTestInfo = {
      hasApiKey: !!applicationId,
      apiKeyLength: applicationId ? applicationId.length : 0,
      apiKeyPreview: applicationId ? `${applicationId.substring(0, 4)}...${applicationId.substring(applicationId.length - 4)}` : 'Not set',
      timestamp: new Date().toISOString(),
      keyword: keyword
    }

    console.log('üîç Rakuten Recipe API Search:', apiTestInfo)

    if (!applicationId) {
      // API„Ç≠„Éº„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç®„É©„Éº„ÇíËøî„Åô
      return NextResponse.json({ 
        recipes: [],
        message: '‚ö†Ô∏è Rakuten API key not configured',
        apiTest: {
          ...apiTestInfo,
          status: 'NO_API_KEY',
          recommendation: 'Set RAKUTEN_APPLICATION_ID environment variable to use real Rakuten Recipe API'
        }
      })
    }

    // Ê•ΩÂ§©„É¨„Ç∑„ÉîAPI„Çí‰ΩøÁî®„Åó„Å¶„É¨„Ç∑„Éî„ÇíÂèñÂæó
    const recipes = await fetchRakutenRecipes(applicationId, keyword, apiTestInfo)
    
    return NextResponse.json(recipes)

  } catch (error) {
    console.error('üí• Rakuten recipe search error:', error)
    // „Ç®„É©„ÉºÊôÇ„ÅØÁ©∫„ÅÆÁµêÊûú„ÇíËøî„Åô
    const { searchParams: errorUrlParams } = new URL(request.url)
    const errorKeyword = errorUrlParams.get('keyword') || '„É¨„Ç∑„Éî'
    return NextResponse.json({ 
      recipes: [],
      message: '‚ùå Error occurred while searching recipes',
      apiTest: {
        hasApiKey: !!process.env.RAKUTEN_APPLICATION_ID,
        status: 'EXCEPTION',
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
        keyword: errorKeyword,
        recommendation: 'Check server logs for detailed error information'
      }
    })
  }
}

// Ê•ΩÂ§©„É¨„Ç∑„ÉîAPI„Åã„Çâ„É¨„Ç∑„Éî„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
async function fetchRakutenRecipes(applicationId: string, keyword: string, apiTestInfo: any) {
  const allRecipes: any[] = []
  
  try {
    // „Åæ„ÅöÊ•ΩÂ§©„É¨„Ç∑„Éî„Ç´„ÉÜ„Ç¥„É™‰∏ÄË¶ßAPI„ÇíÂëº„Å≥Âá∫„Åó„Å¶ÂÆüÈöõ„ÅÆ„Ç´„ÉÜ„Ç¥„É™ID„ÇíÂèñÂæó
    console.log('üîç Fetching category list from Rakuten Recipe API...')
    const categoryApiUrl = `https://app.rakuten.co.jp/services/api/Recipe/CategoryList/20170426`
    const categoryParams = new URLSearchParams({
      applicationId,
      categoryType: 'large'
    })

    const categoryResponse = await fetch(`${categoryApiUrl}?${categoryParams}`)
    
    if (!categoryResponse.ok) {
      console.warn('‚ö†Ô∏è Category List API failed:', categoryResponse.status, categoryResponse.statusText)
      const errorText = await categoryResponse.text()
      console.warn('üìÑ Category API Error Response:', errorText)
      
      return {
        recipes: [],
        message: `‚ùå Category API failed for "${keyword}"`,
        apiTest: {
          ...apiTestInfo,
          status: 'CATEGORY_API_ERROR',
          httpStatus: categoryResponse.status,
          httpStatusText: categoryResponse.statusText,
          errorDetails: errorText,
          recommendation: 'Category List API failed. Check API key permissions for Recipe API access.'
        }
      }
    }

    const categoryData = await categoryResponse.json()
    console.log('‚úÖ Category data received:', categoryData)
    
    // ÂÆüÈöõ„ÅÆ„Ç´„ÉÜ„Ç¥„É™ID„ÇíÂèñÂæó
    const availableCategories = categoryData.result?.large || []
    console.log('üìã Available large categories:', availableCategories.map((cat: any) => `${cat.categoryId}: ${cat.categoryName}`))
    
    if (availableCategories.length === 0) {
      console.warn('‚ö†Ô∏è No categories found in API response')
      return {
        recipes: [],
        message: `‚ùå No categories available for "${keyword}"`,
        apiTest: {
          ...apiTestInfo,
          status: 'NO_CATEGORIES',
          recommendation: 'No categories found in Rakuten Recipe API response.'
        }
      }
    }
    
    // „Ç≠„Éº„ÉØ„Éº„Éâ„Å´Âü∫„Å•„ÅÑ„Å¶ÈÅ©Âàá„Å™„Ç´„ÉÜ„Ç¥„É™ID„ÇíÈÅ∏ÊäûÔºàÂÆüÈöõ„ÅÆ„Ç´„ÉÜ„Ç¥„É™ID„Çí‰ΩøÁî®Ôºâ
    const selectedCategories = selectCategoriesFromAvailable(keyword, availableCategories)
    console.log(`üéØ Selected categories for "${keyword}":`, selectedCategories.map(cat => `${cat.categoryId}: ${cat.categoryName}`))
    
    // ÂêÑ„Ç´„ÉÜ„Ç¥„É™„Åã„Çâ„É¨„Ç∑„Éî„ÇíÂèñÂæó
    for (const category of selectedCategories) {
      try {
        const rakutenApiUrl = `https://app.rakuten.co.jp/services/api/Recipe/CategoryRanking/20170426`
        const apiParams = new URLSearchParams({
          applicationId,
          categoryId: category.categoryId.toString()
        })

        const fullApiUrl = `${rakutenApiUrl}?${apiParams}`
        console.log(`üåê Fetching from category ${category.categoryId} (${category.categoryName}):`, fullApiUrl.replace(applicationId, '***API_KEY***'))

        const response = await fetch(fullApiUrl)
        
        if (!response.ok) {
          console.warn(`‚ö†Ô∏è Category ${category.categoryId} failed:`, response.status, response.statusText)
          const errorText = await response.text()
          console.warn(`üìÑ Error details for category ${category.categoryId}:`, errorText)
          continue
        }

        const data = await response.json()
        console.log(`üìä Category ${category.categoryId} response:`, {
          hasResult: !!data.result,
          resultCount: Array.isArray(data.result) ? data.result.length : 0,
          resultType: typeof data.result
        })
        
        if (data.result && Array.isArray(data.result)) {
          // Ê•ΩÂ§©„É¨„Ç∑„ÉîAPI„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Åó„Å¶Â§âÊèõ
          const categoryRecipes = data.result
            .filter((item: any) => {
              // „Ç≠„Éº„ÉØ„Éº„Éâ„Å´Èñ¢ÈÄ£„Åô„Çã„É¨„Ç∑„Éî„ÅÆ„Åø„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
              const title = item.recipeTitle?.toLowerCase() || ''
              const description = item.recipeDescription?.toLowerCase() || ''
              const materials = Array.isArray(item.recipeMaterial) 
                ? item.recipeMaterial.join(' ').toLowerCase() 
                : ''
              
              const searchKeyword = keyword.toLowerCase()
              return title.includes(searchKeyword) || 
                     description.includes(searchKeyword) || 
                     materials.includes(searchKeyword)
            })
            .map((item: any) => ({
              recipeId: item.recipeId?.toString() || `rakuten_${Date.now()}_${Math.random()}`,
              recipeTitle: item.recipeTitle || '',
              recipeUrl: item.recipeUrl || '',
              foodImageUrl: item.foodImageUrl || '',
              recipeDescription: item.recipeDescription || '',
              recipeMaterial: Array.isArray(item.recipeMaterial) ? item.recipeMaterial : [],
              recipeIndication: item.recipeIndication || '',
              recipeInstructions: item.recipeInstructions || '', // Ê•ΩÂ§©API„Åã„ÇâÂèñÂæó„Åß„Åç„ÇãÂ†¥Âêà„ÅÆ„Åø
              categoryName: category.categoryName,
              nickname: item.nickname || '',
              recipePublishday: item.recipePublishday || '',
              shop: item.shop || 0,
              pickup: item.pickup || 0,
              rank: item.rank?.toString() || ''
            }))
          
          allRecipes.push(...categoryRecipes)
          console.log(`‚úÖ Category ${category.categoryId}: Found ${categoryRecipes.length} matching recipes`)
        }
        
        // API„É¨„Éº„ÉàÂà∂Èôê„ÇíÈÅø„Åë„Çã„Åü„ÇÅÂ∞ë„ÅóÂæÖÊ©ü
        await new Promise(resolve => setTimeout(resolve, 500))
        
      } catch (error) {
        console.error(`‚ùå Error fetching category ${category.categoryId}:`, error)
        continue
      }
    }
    
    // „É¨„Ç∑„Éî„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÁ©∫„ÅÆÁµêÊûú„ÇíËøî„Åô
    if (allRecipes.length === 0) {
      console.log('üìù No recipes found from API')
      
      return {
        recipes: [],
        message: `‚ùå No recipes found for "${keyword}" in Rakuten Recipe API`,
        apiTest: {
          ...apiTestInfo,
          status: 'NO_MATCHES',
          categoriesSearched: selectedCategories.map(cat => `${cat.categoryId}: ${cat.categoryName}`),
          availableCategories: availableCategories.map((cat: any) => `${cat.categoryId}: ${cat.categoryName}`),
          recommendation: 'Try different keywords or check if the recipes exist in Rakuten Recipe database'
        }
      }
    }
    
    return {
      recipes: allRecipes.slice(0, 20), // ÊúÄÂ§ß20‰ª∂„Å´Âà∂Èôê
      message: `‚úÖ Found ${allRecipes.length} recipes for "${keyword}" from Rakuten Recipe API`,
      apiTest: {
        ...apiTestInfo,
        status: 'SUCCESS',
        categoriesSearched: selectedCategories.map(cat => `${cat.categoryId}: ${cat.categoryName}`),
        availableCategories: availableCategories.map((cat: any) => `${cat.categoryId}: ${cat.categoryName}`),
        totalFound: allRecipes.length
      }
    }
    
  } catch (error) {
    console.error('üí• Error in fetchRakutenRecipes:', error)
    return {
      recipes: [],
      message: `‚ùå Error occurred while fetching recipes for "${keyword}"`,
      apiTest: {
        ...apiTestInfo,
        status: 'EXCEPTION',
        error: error instanceof Error ? error.message : 'Unknown error',
        recommendation: 'Check server logs for detailed error information'
      }
    }
  }
}

// Âà©Áî®ÂèØËÉΩ„Å™„Ç´„ÉÜ„Ç¥„É™„Åã„Çâ„Ç≠„Éº„ÉØ„Éº„Éâ„Å´ÈÅ©„Åó„Åü„ÇÇ„ÅÆ„ÇíÈÅ∏Êäû
function selectCategoriesFromAvailable(keyword: string, availableCategories: any[]): any[] {
  const keywordLower = keyword.toLowerCase()
  
  // „Ç≠„Éº„ÉØ„Éº„Éâ„Å´Âü∫„Å•„ÅÑ„Å¶„Ç´„ÉÜ„Ç¥„É™Âêç„ÅßÊ§úÁ¥¢
  const matchingCategories = availableCategories.filter(category => {
    const categoryName = category.categoryName?.toLowerCase() || ''
    
    if (keywordLower.includes('ËÇâ') || keywordLower.includes('Áâõ') || keywordLower.includes('Ë±ö') || keywordLower.includes('È∂è')) {
      return categoryName.includes('ËÇâ') || categoryName.includes('„ÅäËÇâ')
    } else if (keywordLower.includes('È≠ö') || keywordLower.includes('„Çµ„Éº„É¢„É≥') || keywordLower.includes('„Éû„Ç∞„É≠')) {
      return categoryName.includes('È≠ö') || categoryName.includes('È≠ö‰ªã')
    } else if (keywordLower.includes('ÈáéËèú') || keywordLower.includes('„Ç≠„É£„Éô„ÉÑ') || keywordLower.includes('‰∫∫ÂèÇ')) {
      return categoryName.includes('ÈáéËèú')
    } else if (keywordLower.includes('„Çµ„É©„ÉÄ')) {
      return categoryName.includes('„Çµ„É©„ÉÄ')
    } else if (keywordLower.includes('„Çπ„Éº„Éó') || keywordLower.includes('Ê±ÅÁâ©')) {
      return categoryName.includes('„Çπ„Éº„Éó') || categoryName.includes('Ê±Å')
    } else if (keywordLower.includes('„Éë„Çπ„Çø') || keywordLower.includes('„Ç∞„É©„Çø„É≥')) {
      return categoryName.includes('„Éë„Çπ„Çø') || categoryName.includes('„Ç∞„É©„Çø„É≥')
    } else if (keywordLower.includes('„ÅîÈ£Ø') || keywordLower.includes('‰∏º') || keywordLower.includes('Á±≥')) {
      return categoryName.includes('„ÅîÈ£Ø') || categoryName.includes('‰∏º')
    } else if (keywordLower.includes('„Éá„Ç∂„Éº„Éà') || keywordLower.includes('„Çπ„Ç§„Éº„ÉÑ') || keywordLower.includes('„Ç±„Éº„Ç≠')) {
      return categoryName.includes('„ÅäËèìÂ≠ê') || categoryName.includes('„Éá„Ç∂„Éº„Éà') || categoryName.includes('„Çπ„Ç§„Éº„ÉÑ')
    }
    
    return false
  })
  
  // „Éû„ÉÉ„ÉÅ„Åô„Çã„Ç´„ÉÜ„Ç¥„É™„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰∫∫Ê∞ó„Åù„ÅÜ„Å™„Ç´„ÉÜ„Ç¥„É™„ÇíÈÅ∏Êäû
  if (matchingCategories.length === 0) {
    console.log('üîÑ No matching categories found, selecting popular categories')
    return availableCategories.slice(0, 3) // ÊúÄÂàù„ÅÆ3„Å§„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇíÈÅ∏Êäû
  }
  
  return matchingCategories.slice(0, 3) // ÊúÄÂ§ß3„Å§„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇíÈÅ∏Êäû
} 